# 操作系统考察点

[TOC]

## 一、常考 Linux 命令

### 1、如何查询 Linux 命令？

- 使用 man 命令查询。比较晦涩
- 使用工具自带的 help 参数
- man 的替代工具 **tldr**。`pip install tldr`

### 2、文件/目录操作命令


### 3、进程操作命令



### 4、内存操作命令



### 5、网络操作命令



### 6、用户/组操作



---



## 二、线程和进程常考题

### 1、进程和线程的区别

进程和线程对比：

- **进程**是对运行时程序的封装，是**系统资源调度和分配的基本单位**
- **线程**是进程的子任务，是 **cpu 调度和分配的基本单位**，实现进程内并发
- 一个进程可以包含多个线程，线程依赖进程存在，并共享进程内存

### 2、什么是线程安全？

 引发线程安全问题的原因：**同一进程内多个线程共享进程数据**，多个线程同时修改进程数据，会导致多个进程之间修改覆盖（类似于数据库事务的未提交读）。锁机制

- 线程安全：一个操作可以在多线程环境中安全使用，获取正确的结果
- 线程安全的操作好比**线程是顺序执行**而不是并发执行
- 一般涉及到**写操作**需要考虑多个线程安全访问数据

### 3、线程同步的方式

- 互斥量（锁）：通过互斥机制防止多个线程同时访问公共资源（特殊的信号量）
- 信号量：控制同一时刻多个线程访问同一个资源的线程数 `threading.semaphore`

- 事件（信号）：通过互相通知的方式保持多个线程同步 `threading.event`

### 4、进程间通信方式

IPC（Inter-Process Communication）进程间传递信号或数据

- 管道（pipe）/匿名管道/命名管道（FIFO）
- 信号
- 消息队列
- 共享内存
- 信号量
- 套接字

### 5、Python 中如何使用多线程

`threading` 模块

- `threading.Thread` 类用来创建线程
- `start()` 方法启动线程
- `join()` 方法等待线程结束

### 6、Python 中如何使用多进程

Python 有 GIL，可以用多进程实现 CPU 密集型程序

- `multiprocessing` 多进程模块
- `multiprocessing.Process` 类创建进程
- 一般用在 CPU 密集程序中，避免 GIL 的影响

---



## 三、内存管理机制和 Python 垃圾回收面试题

### 1、什么是分页机制

分页机制：逻辑地址和物理地址分类的内存分配管理方案

- 程序的逻辑地址划分为固定大小的页（Page）
- 物理地址划分为同样大小的帧（页框）（Frame）
- 通过页表对应逻辑地址和物理地址

![1552617780535](C:\Users\SXN\AppData\Roaming\Typora\typora-user-images\1552617780535.png)

### 2、什么的分段机制

分段是为了满足代码的一些逻辑需求

- 数据共享，数据保护，动态链接等
- 通过段表实现逻辑地址和物理地址的映射关系
- 每个段内部是连续内存分配，段和段之间是离散分配的

![1552618104267](C:\Users\SXN\AppData\Roaming\Typora\typora-user-images\1552618104267.png)

### 3、分页和分段的区别

- 页是出于内存利用率的角度提出的离散分配机制
- 段是出于用户角度，用于数据保护、数据隔离等用途的管理机制
- 页的大小是固定的，由操作系统决定；段的大小不确定，由用户查询决定

### 4、什么是虚拟内存

通过把一部分暂时不同的内存信息放到硬盘上

- 局部性原理，程序运行时只有部分必要的信息装入内存
- 内存中暂时不需要的内容放到硬盘上
- 系统似乎提供了比实际内存大得多的容量，即虚拟内存

### 5、什么是内存抖动（颠簸）

本质是 **频繁的页调度行为**

- 频繁的页调度，进程不断产生缺页中断
- 置换一个页，又不断再次需要这个页
- 运行程序太多，页面替换策略不好。终止进程h或增加物理内存

### 6、Python 的垃圾回收机制原理

- **引用计数**（循环引用无法解决）
  - 某个引用变量指向了另一个对象，或 `del` 了该变量，对象的 ref 计数减一
  - 对象的 ref 计数归零则被回收
- 引入**标记清除**和**分代回收**解决引用计数问题
  - **标记清除**：从垃圾回收根对象开始标记所有可达对象节点，所有不可达对象节点被回收
  - **分代回收**：对象生命周期分为三代，每一代引用都是双向链表，当每一代达到了对应的阈值（对象个数/链表长度）就会执行标记清除。`gc.get_threshold()` 获取三代阈值
- 引用计数为主 + 标记清除和分代回收为辅

---


